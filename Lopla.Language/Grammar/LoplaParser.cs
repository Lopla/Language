/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.4.0.0
 */
using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Lopla.Language.Grammar
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	internal class LoplaParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(LoplaParser), "LoplaParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable value
			/// </summary>
			public const int VariableValue = 0x0018;
			/// <summary>
			/// The unique identifier for variable emptyLine
			/// </summary>
			public const int VariableEmptyLine = 0x0019;
			/// <summary>
			/// The unique identifier for variable type_name
			/// </summary>
			public const int VariableTypeName = 0x001A;
			/// <summary>
			/// The unique identifier for variable variable_name
			/// </summary>
			public const int VariableVariableName = 0x001B;
			/// <summary>
			/// The unique identifier for variable method_name
			/// </summary>
			public const int VariableMethodName = 0x001C;
			/// <summary>
			/// The unique identifier for variable namespace
			/// </summary>
			public const int VariableNamespace = 0x001D;
			/// <summary>
			/// The unique identifier for variable expression_arg
			/// </summary>
			public const int VariableExpressionArg = 0x001E;
			/// <summary>
			/// The unique identifier for variable expression_prefix
			/// </summary>
			public const int VariableExpressionPrefix = 0x001F;
			/// <summary>
			/// The unique identifier for variable expression_bracket
			/// </summary>
			public const int VariableExpressionBracket = 0x0020;
			/// <summary>
			/// The unique identifier for variable expression_mult
			/// </summary>
			public const int VariableExpressionMult = 0x0021;
			/// <summary>
			/// The unique identifier for variable expression_sum
			/// </summary>
			public const int VariableExpressionSum = 0x0022;
			/// <summary>
			/// The unique identifier for variable expression_bool
			/// </summary>
			public const int VariableExpressionBool = 0x0023;
			/// <summary>
			/// The unique identifier for variable expression_cmp
			/// </summary>
			public const int VariableExpressionCmp = 0x0024;
			/// <summary>
			/// The unique identifier for variable expression
			/// </summary>
			public const int VariableExpression = 0x0025;
			/// <summary>
			/// The unique identifier for variable declare_table_values
			/// </summary>
			public const int VariableDeclareTableValues = 0x0026;
			/// <summary>
			/// The unique identifier for variable declare_table
			/// </summary>
			public const int VariableDeclareTable = 0x0027;
			/// <summary>
			/// The unique identifier for variable var_value_table
			/// </summary>
			public const int VariableVarValueTable = 0x0028;
			/// <summary>
			/// The unique identifier for variable var_value
			/// </summary>
			public const int VariableVarValue = 0x0029;
			/// <summary>
			/// The unique identifier for variable method_arguments
			/// </summary>
			public const int VariableMethodArguments = 0x002A;
			/// <summary>
			/// The unique identifier for variable method_call
			/// </summary>
			public const int VariableMethodCall = 0x002B;
			/// <summary>
			/// The unique identifier for variable assigment
			/// </summary>
			public const int VariableAssigment = 0x002C;
			/// <summary>
			/// The unique identifier for variable block_of_lopla
			/// </summary>
			public const int VariableBlockOfLopla = 0x002D;
			/// <summary>
			/// The unique identifier for variable if
			/// </summary>
			public const int VariableIf = 0x002E;
			/// <summary>
			/// The unique identifier for variable while
			/// </summary>
			public const int VariableWhile = 0x002F;
			/// <summary>
			/// The unique identifier for variable method_parameters
			/// </summary>
			public const int VariableMethodParameters = 0x0030;
			/// <summary>
			/// The unique identifier for variable method
			/// </summary>
			public const int VariableMethod = 0x0031;
			/// <summary>
			/// The unique identifier for variable return
			/// </summary>
			public const int VariableReturn = 0x0032;
			/// <summary>
			/// The unique identifier for variable lopla_oneliners
			/// </summary>
			public const int VariableLoplaOneliners = 0x0033;
			/// <summary>
			/// The unique identifier for variable lopla_blocks
			/// </summary>
			public const int VariableLoplaBlocks = 0x0034;
			/// <summary>
			/// The unique identifier for variable lopla_line
			/// </summary>
			public const int VariableLoplaLine = 0x0035;
			/// <summary>
			/// The unique identifier for variable lopla_root_line
			/// </summary>
			public const int VariableLoplaRootLine = 0x0036;
			/// <summary>
			/// The unique identifier for variable lopla
			/// </summary>
			public const int VariableLopla = 0x0037;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0018, "value"), 
			new Symbol(0x0019, "emptyLine"), 
			new Symbol(0x001A, "type_name"), 
			new Symbol(0x001B, "variable_name"), 
			new Symbol(0x001C, "method_name"), 
			new Symbol(0x001D, "namespace"), 
			new Symbol(0x001E, "expression_arg"), 
			new Symbol(0x001F, "expression_prefix"), 
			new Symbol(0x0020, "expression_bracket"), 
			new Symbol(0x0021, "expression_mult"), 
			new Symbol(0x0022, "expression_sum"), 
			new Symbol(0x0023, "expression_bool"), 
			new Symbol(0x0024, "expression_cmp"), 
			new Symbol(0x0025, "expression"), 
			new Symbol(0x0026, "declare_table_values"), 
			new Symbol(0x0027, "declare_table"), 
			new Symbol(0x0028, "var_value_table"), 
			new Symbol(0x0029, "var_value"), 
			new Symbol(0x002A, "method_arguments"), 
			new Symbol(0x002B, "method_call"), 
			new Symbol(0x002C, "assigment"), 
			new Symbol(0x002D, "block_of_lopla"), 
			new Symbol(0x002E, "if"), 
			new Symbol(0x002F, "while"), 
			new Symbol(0x0030, "method_parameters"), 
			new Symbol(0x0031, "method"), 
			new Symbol(0x0032, "return"), 
			new Symbol(0x0033, "lopla_oneliners"), 
			new Symbol(0x0034, "lopla_blocks"), 
			new Symbol(0x0035, "lopla_line"), 
			new Symbol(0x0036, "lopla_root_line"), 
			new Symbol(0x0037, "lopla"), 
			new Symbol(0x0047, "__V71"), 
			new Symbol(0x004A, "__V74"), 
			new Symbol(0x004D, "__V77"), 
			new Symbol(0x004F, "__V79"), 
			new Symbol(0x0051, "__V81"), 
			new Symbol(0x0054, "__V84"), 
			new Symbol(0x0056, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Represents a set of semantic actions in this parser
		/// </summary>
		public class Actions
		{
			/// <summary>
			/// The OnLopla semantic action
			/// </summary>
			public virtual void OnLopla(Symbol head, SemanticBody body) {}

		}
		/// <summary>
		/// Represents a set of empty semantic actions (do nothing)
		/// </summary>
		private static readonly Actions noActions = new Actions();
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(Actions input)
		{
			SemanticAction[] result = new SemanticAction[1];
			result[0] = new SemanticAction(input.OnLopla);
			return result;
		}
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(Dictionary<string, SemanticAction> input)
		{
			SemanticAction[] result = new SemanticAction[1];
			result[0] = input["OnLopla"];
			return result;
		}
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public LoplaParser(LoplaLexer lexer) : base (commonAutomaton, variables, virtuals, GetUserActions(noActions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public LoplaParser(LoplaLexer lexer, Actions actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public LoplaParser(LoplaLexer lexer, Dictionary<string, SemanticAction> actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		public class Visitor
		{
			public virtual void OnTerminalNewLine(ASTNode node) {}
			public virtual void OnTerminalTab(ASTNode node) {}
			public virtual void OnTerminalWhiteSpace(ASTNode node) {}
			public virtual void OnTerminalComment(ASTNode node) {}
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnTerminalChar(ASTNode node) {}
			public virtual void OnTerminalDigit(ASTNode node) {}
			public virtual void OnTerminalDecimal(ASTNode node) {}
			public virtual void OnTerminalInteger(ASTNode node) {}
			public virtual void OnTerminalReal(ASTNode node) {}
			public virtual void OnTerminalNumber(ASTNode node) {}
			public virtual void OnTerminalString(ASTNode node) {}
			public virtual void OnTerminalIf(ASTNode node) {}
			public virtual void OnTerminalFi(ASTNode node) {}
			public virtual void OnTerminalThen(ASTNode node) {}
			public virtual void OnTerminalTo(ASTNode node) {}
			public virtual void OnTerminalFrom(ASTNode node) {}
			public virtual void OnTerminalStep(ASTNode node) {}
			public virtual void OnTerminalWhile(ASTNode node) {}
			public virtual void OnTerminalLiteral(ASTNode node) {}
			public virtual void OnTerminalOperatorTerm(ASTNode node) {}
			public virtual void OnVariableValue(ASTNode node) {}
			public virtual void OnVariableEmptyLine(ASTNode node) {}
			public virtual void OnVariableTypeName(ASTNode node) {}
			public virtual void OnVariableVariableName(ASTNode node) {}
			public virtual void OnVariableMethodName(ASTNode node) {}
			public virtual void OnVariableNamespace(ASTNode node) {}
			public virtual void OnVariableExpressionArg(ASTNode node) {}
			public virtual void OnVariableExpressionPrefix(ASTNode node) {}
			public virtual void OnVariableExpressionBracket(ASTNode node) {}
			public virtual void OnVariableExpressionMult(ASTNode node) {}
			public virtual void OnVariableExpressionSum(ASTNode node) {}
			public virtual void OnVariableExpressionBool(ASTNode node) {}
			public virtual void OnVariableExpressionCmp(ASTNode node) {}
			public virtual void OnVariableExpression(ASTNode node) {}
			public virtual void OnVariableDeclareTableValues(ASTNode node) {}
			public virtual void OnVariableDeclareTable(ASTNode node) {}
			public virtual void OnVariableVarValueTable(ASTNode node) {}
			public virtual void OnVariableVarValue(ASTNode node) {}
			public virtual void OnVariableMethodArguments(ASTNode node) {}
			public virtual void OnVariableMethodCall(ASTNode node) {}
			public virtual void OnVariableAssigment(ASTNode node) {}
			public virtual void OnVariableBlockOfLopla(ASTNode node) {}
			public virtual void OnVariableIf(ASTNode node) {}
			public virtual void OnVariableWhile(ASTNode node) {}
			public virtual void OnVariableMethodParameters(ASTNode node) {}
			public virtual void OnVariableMethod(ASTNode node) {}
			public virtual void OnVariableReturn(ASTNode node) {}
			public virtual void OnVariableLoplaOneliners(ASTNode node) {}
			public virtual void OnVariableLoplaBlocks(ASTNode node) {}
			public virtual void OnVariableLoplaLine(ASTNode node) {}
			public virtual void OnVariableLoplaRootLine(ASTNode node) {}
			public virtual void OnVariableLopla(ASTNode node) {}
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void Visit(ParseResult result, Visitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the AST using a visitor
		/// </summary>
		public static void VisitASTNode(ASTNode node, Visitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0003: visitor.OnTerminalNewLine(node); break;
				case 0x0004: visitor.OnTerminalTab(node); break;
				case 0x0005: visitor.OnTerminalWhiteSpace(node); break;
				case 0x0006: visitor.OnTerminalComment(node); break;
				case 0x0007: visitor.OnTerminalSeparator(node); break;
				case 0x0008: visitor.OnTerminalChar(node); break;
				case 0x0009: visitor.OnTerminalDigit(node); break;
				case 0x000A: visitor.OnTerminalDecimal(node); break;
				case 0x000B: visitor.OnTerminalInteger(node); break;
				case 0x000C: visitor.OnTerminalReal(node); break;
				case 0x000D: visitor.OnTerminalNumber(node); break;
				case 0x000E: visitor.OnTerminalString(node); break;
				case 0x000F: visitor.OnTerminalIf(node); break;
				case 0x0010: visitor.OnTerminalFi(node); break;
				case 0x0011: visitor.OnTerminalThen(node); break;
				case 0x0012: visitor.OnTerminalTo(node); break;
				case 0x0013: visitor.OnTerminalFrom(node); break;
				case 0x0014: visitor.OnTerminalStep(node); break;
				case 0x0015: visitor.OnTerminalWhile(node); break;
				case 0x0016: visitor.OnTerminalLiteral(node); break;
				case 0x0017: visitor.OnTerminalOperatorTerm(node); break;
				case 0x0018: visitor.OnVariableValue(node); break;
				case 0x0019: visitor.OnVariableEmptyLine(node); break;
				case 0x001A: visitor.OnVariableTypeName(node); break;
				case 0x001B: visitor.OnVariableVariableName(node); break;
				case 0x001C: visitor.OnVariableMethodName(node); break;
				case 0x001D: visitor.OnVariableNamespace(node); break;
				case 0x001E: visitor.OnVariableExpressionArg(node); break;
				case 0x001F: visitor.OnVariableExpressionPrefix(node); break;
				case 0x0020: visitor.OnVariableExpressionBracket(node); break;
				case 0x0021: visitor.OnVariableExpressionMult(node); break;
				case 0x0022: visitor.OnVariableExpressionSum(node); break;
				case 0x0023: visitor.OnVariableExpressionBool(node); break;
				case 0x0024: visitor.OnVariableExpressionCmp(node); break;
				case 0x0025: visitor.OnVariableExpression(node); break;
				case 0x0026: visitor.OnVariableDeclareTableValues(node); break;
				case 0x0027: visitor.OnVariableDeclareTable(node); break;
				case 0x0028: visitor.OnVariableVarValueTable(node); break;
				case 0x0029: visitor.OnVariableVarValue(node); break;
				case 0x002A: visitor.OnVariableMethodArguments(node); break;
				case 0x002B: visitor.OnVariableMethodCall(node); break;
				case 0x002C: visitor.OnVariableAssigment(node); break;
				case 0x002D: visitor.OnVariableBlockOfLopla(node); break;
				case 0x002E: visitor.OnVariableIf(node); break;
				case 0x002F: visitor.OnVariableWhile(node); break;
				case 0x0030: visitor.OnVariableMethodParameters(node); break;
				case 0x0031: visitor.OnVariableMethod(node); break;
				case 0x0032: visitor.OnVariableReturn(node); break;
				case 0x0033: visitor.OnVariableLoplaOneliners(node); break;
				case 0x0034: visitor.OnVariableLoplaBlocks(node); break;
				case 0x0035: visitor.OnVariableLoplaLine(node); break;
				case 0x0036: visitor.OnVariableLoplaRootLine(node); break;
				case 0x0037: visitor.OnVariableLopla(node); break;
			}
		}
	}
}
