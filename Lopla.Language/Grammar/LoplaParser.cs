/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.3.2.0
 */
using System.Collections.Generic;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Lopla.Language.Grammar
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	internal class LoplaParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(LoplaParser), "LoplaParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable value
			/// </summary>
			public const int VariableValue = 0x0018;
			/// <summary>
			/// The unique identifier for variable emptyLine
			/// </summary>
			public const int VariableEmptyLine = 0x0019;
			/// <summary>
			/// The unique identifier for variable type_name
			/// </summary>
			public const int VariableTypeName = 0x001A;
			/// <summary>
			/// The unique identifier for variable variable_name
			/// </summary>
			public const int VariableVariableName = 0x001B;
			/// <summary>
			/// The unique identifier for variable method_name
			/// </summary>
			public const int VariableMethodName = 0x001C;
			/// <summary>
			/// The unique identifier for variable namespace
			/// </summary>
			public const int VariableNamespace = 0x001D;
			/// <summary>
			/// The unique identifier for variable expression_arg
			/// </summary>
			public const int VariableExpressionArg = 0x001E;
			/// <summary>
			/// The unique identifier for variable expression_prefix
			/// </summary>
			public const int VariableExpressionPrefix = 0x001F;
			/// <summary>
			/// The unique identifier for variable expression_bracket
			/// </summary>
			public const int VariableExpressionBracket = 0x0020;
			/// <summary>
			/// The unique identifier for variable expression_mult
			/// </summary>
			public const int VariableExpressionMult = 0x0021;
			/// <summary>
			/// The unique identifier for variable expression_sum
			/// </summary>
			public const int VariableExpressionSum = 0x0022;
			/// <summary>
			/// The unique identifier for variable expression_bool
			/// </summary>
			public const int VariableExpressionBool = 0x0023;
			/// <summary>
			/// The unique identifier for variable expression_cmp
			/// </summary>
			public const int VariableExpressionCmp = 0x0024;
			/// <summary>
			/// The unique identifier for variable expression
			/// </summary>
			public const int VariableExpression = 0x0025;
			/// <summary>
			/// The unique identifier for variable declare_table_values
			/// </summary>
			public const int VariableDeclareTableValues = 0x0026;
			/// <summary>
			/// The unique identifier for variable declare_table
			/// </summary>
			public const int VariableDeclareTable = 0x0027;
			/// <summary>
			/// The unique identifier for variable var_value_table
			/// </summary>
			public const int VariableVarValueTable = 0x0028;
			/// <summary>
			/// The unique identifier for variable var_value
			/// </summary>
			public const int VariableVarValue = 0x0029;
			/// <summary>
			/// The unique identifier for variable method_arguments
			/// </summary>
			public const int VariableMethodArguments = 0x002A;
			/// <summary>
			/// The unique identifier for variable method_call
			/// </summary>
			public const int VariableMethodCall = 0x002B;
			/// <summary>
			/// The unique identifier for variable assigment
			/// </summary>
			public const int VariableAssigment = 0x002C;
			/// <summary>
			/// The unique identifier for variable block_of_lopla
			/// </summary>
			public const int VariableBlockOfLopla = 0x002D;
			/// <summary>
			/// The unique identifier for variable if_lines
			/// </summary>
			public const int VariableIfLines = 0x002E;
			/// <summary>
			/// The unique identifier for variable if
			/// </summary>
			public const int VariableIf = 0x002F;
			/// <summary>
			/// The unique identifier for variable while
			/// </summary>
			public const int VariableWhile = 0x0030;
			/// <summary>
			/// The unique identifier for variable method_parameters
			/// </summary>
			public const int VariableMethodParameters = 0x0031;
			/// <summary>
			/// The unique identifier for variable method
			/// </summary>
			public const int VariableMethod = 0x0032;
			/// <summary>
			/// The unique identifier for variable return
			/// </summary>
			public const int VariableReturn = 0x0033;
			/// <summary>
			/// The unique identifier for variable lopla_oneliners
			/// </summary>
			public const int VariableLoplaOneliners = 0x0034;
			/// <summary>
			/// The unique identifier for variable lopla_blocks
			/// </summary>
			public const int VariableLoplaBlocks = 0x0035;
			/// <summary>
			/// The unique identifier for variable lopla_line
			/// </summary>
			public const int VariableLoplaLine = 0x0036;
			/// <summary>
			/// The unique identifier for variable lopla_root_line
			/// </summary>
			public const int VariableLoplaRootLine = 0x0037;
			/// <summary>
			/// The unique identifier for variable lopla
			/// </summary>
			public const int VariableLopla = 0x0038;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0018, "value"), 
			new Symbol(0x0019, "emptyLine"), 
			new Symbol(0x001A, "type_name"), 
			new Symbol(0x001B, "variable_name"), 
			new Symbol(0x001C, "method_name"), 
			new Symbol(0x001D, "namespace"), 
			new Symbol(0x001E, "expression_arg"), 
			new Symbol(0x001F, "expression_prefix"), 
			new Symbol(0x0020, "expression_bracket"), 
			new Symbol(0x0021, "expression_mult"), 
			new Symbol(0x0022, "expression_sum"), 
			new Symbol(0x0023, "expression_bool"), 
			new Symbol(0x0024, "expression_cmp"), 
			new Symbol(0x0025, "expression"), 
			new Symbol(0x0026, "declare_table_values"), 
			new Symbol(0x0027, "declare_table"), 
			new Symbol(0x0028, "var_value_table"), 
			new Symbol(0x0029, "var_value"), 
			new Symbol(0x002A, "method_arguments"), 
			new Symbol(0x002B, "method_call"), 
			new Symbol(0x002C, "assigment"), 
			new Symbol(0x002D, "block_of_lopla"), 
			new Symbol(0x002E, "if_lines"), 
			new Symbol(0x002F, "if"), 
			new Symbol(0x0030, "while"), 
			new Symbol(0x0031, "method_parameters"), 
			new Symbol(0x0032, "method"), 
			new Symbol(0x0033, "return"), 
			new Symbol(0x0034, "lopla_oneliners"), 
			new Symbol(0x0035, "lopla_blocks"), 
			new Symbol(0x0036, "lopla_line"), 
			new Symbol(0x0037, "lopla_root_line"), 
			new Symbol(0x0038, "lopla"), 
			new Symbol(0x0048, "__V72"), 
			new Symbol(0x004B, "__V75"), 
			new Symbol(0x004E, "__V78"), 
			new Symbol(0x0050, "__V80"), 
			new Symbol(0x0052, "__V82"), 
			new Symbol(0x0053, "__V83"), 
			new Symbol(0x0056, "__V86"), 
			new Symbol(0x0058, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Represents a set of semantic actions in this parser
		/// </summary>
		public class Actions
		{
			/// <summary>
			/// The OnLopla semantic action
			/// </summary>
			public virtual void OnLopla(Symbol head, SemanticBody body) { }

		}
		/// <summary>
		/// Represents a set of empty semantic actions (do nothing)
		/// </summary>
		private static readonly Actions noActions = new Actions();
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(Actions input)
		{
			SemanticAction[] result = new SemanticAction[1];
			result[0] = new SemanticAction(input.OnLopla);
			return result;
		}
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(Dictionary<string, SemanticAction> input)
		{
			SemanticAction[] result = new SemanticAction[1];
			result[0] = input["OnLopla"];
			return result;
		}
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public LoplaParser(LoplaLexer lexer) : base (commonAutomaton, variables, virtuals, GetUserActions(noActions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public LoplaParser(LoplaLexer lexer, Actions actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public LoplaParser(LoplaLexer lexer, Dictionary<string, SemanticAction> actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }
	}
}
